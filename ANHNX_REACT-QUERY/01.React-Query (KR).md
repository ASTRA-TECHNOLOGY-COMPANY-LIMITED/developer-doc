# 반응 쿼리

# 사용

// App.js

` import { QueryClient, QueryClientProvider } from 'react-query'`

` const queryClient = new QueryClient()`

<QueryClientProvider client={queryClient}>
  <App />
</QueryClientProvider>

## 리액트 쿼리란?

TanStack Query(새 이름) 또는 React Query는 API의 데이터와 같은 비동기 상태를 관리하는 데 도움이 되는 라이브러리입니다.

Tanstack 쿼리의 힘

- 제로 구성으로 매우 간단한 데이터 캐시 관리 및 업데이트

> React Query를 사용하여 데이터 쿼리를 실행하면 해당 쿼리에서 반환된 결과를 자동으로 캐시합니다. 동일한 쿼리를 계속 실행하면 React Query는 먼저 결과가 이미 캐시되었는지 확인합니다. 그렇다면 새 네트워크 요청을 보내지 않고 즉시 캐시에서 결과를 반환합니다.

> React Query는 데이터 캐시를 자동으로 관리하고 간단하고 유연한 데이터 업데이트 메커니즘을 제공합니다.

> React Query는 데이터 캐시를 자동으로 관리하고 간단하고 유연한 데이터 업데이트 메커니즘을 제공합니다.

- 글로벌 상태, 리듀서를 사용하지 않고 관리하기 위해, 학문적으로 이해하기 힘든 것이 아니라!

  > Redux에서는 전역 상태를 정의하고 감속기를 사용하여 상태를 변경해야 합니다. 이를 위해서는 Redux에 대한 지식과 Redux 작동 방식이 필요합니다.

  > 그러나 React Query를 사용하면 전역 상태를 정의 및 관리하거나 감속기를 사용할 필요가 없습니다. React Query를 사용하면 자동화되고 간단한 방식으로 상태를 관리하고 데이터를 가져올 수 있습니다. useQuery, useMutation 및 useQueryClient와 같은 후크를 제공하여 서버에서 데이터에 액세스하고 업데이트합니다. 상태 저장 및 업데이트에 대해 걱정할 필요가 없습니다. React Query가 자동으로 상태를 관리합니다.

  # react-query의 이점

1. API용 캐싱 데이터 2.중복 요청 다중 호출 제한
2. 아래 API의 데이터를 자동으로 업데이트하여 데이터를 최신 상태로 유지하고 서버와 동기화합니다.
3. 페이지 매김 및 지연 로딩
4. 제어 가능한 데이터가 오래된 경우 쉽게 불러올 수 있습니다.
5. "인스턴트" 데이터로 웹 앱의 UX 경험 향상

# 사용

- GET: list-items - list-items의 모든 항목 가져오기
- POST: 목록 항목 – 목록 항목에 항목 추가
- PUT: list-items/${listItemId} – 항목 업데이트

- DELETE: list-items/${listItemId} -목록 항목에서 항목 제거

일반적인 질문에 대한 답변:

Tanstack Query는 API를 호출하기 위해 무엇을 사용합니까?

Tanstack Query는 API 호출을 처리하지 않으며 API 호출은 axios, fetch API와 같이 사용하는 라이브러리를 통해 수행됩니다. Tanstack Query는 필요할 때만 데이터 관리 및 트리거를 처리합니다.

> Tansatck는 특정 프로젝트에서 소프트웨어 개발 기술과 도구의 조합을 나타내는 데 사용되는 용어입니다. Tansatck는 애플리케이션을 구축하고 배포하는 데 사용되는 툴킷, 프레임워크 또는 기술 스택으로 볼 수 있습니다. Tansatck는 일반적으로 서버측 기술, 클라이언트측 기술, 데이터베이스, 개발 도구 및 기타 추가 기능 라이브러리와 같은 구성 요소를 포함합니다. 인기 있는 tansatck의 예로는 MERN(MongoDB, Express, React, Node.js)이 있습니다. 여기서 MongoDB는 데이터베이스로, Express는 서버 측 프레임워크, React는 클라이언트 측 프레임워크, Node.js는 서버입니다. -측 프레임워크 서버측 런타임 환경.

## 몇 가지 중요한 개념

- `staleTime`(기본 `0` ms): 데이터가 오래된 것으로 간주되는 시간입니다. 데이터 가져오기가 완료되면 지정된 시간이 지나면 데이터 자체가 오래됨

> 데이터가 오래되었다고 말하는 시간입니다. 데이터 가져오기가 완료되면 지정된 시간이 지나면 데이터 자체가 오래됩니다. 기본값 0은 가져오기가 완료되었을 때입니다. 오래된 것입니다.

- 오래된 데이터라고 부르는 이유는 무엇입니까?

> React Query에서 useQuery를 사용하여 서버에서 데이터를 가져오기 위한 쿼리를 수행하면 서버에서 새로운 데이터를 가져오기 위한 요청을 보냅니다. 새 데이터가 반환되기를 기다리는 동안 React Query는 캐시에서 이전 데이터를 반환합니다(사용 가능한 경우). 이를 통해 애플리케이션은 기존 데이터를 표시할 수 있으므로 새 데이터를 기다리지 않고 즉시 렌더링하여 사용자 경험을 향상시킵니다.

> 그러나 서버에서 새로운 데이터가 반환되면 React Query는 이를 이전 데이터와 비교합니다. 새 데이터가 이전 데이터와 다른 경우 React Query는 캐시의 데이터를 업데이트하고 useQuery를 사용한 구성 요소에 변경 사항을 알립니다. 그러나 새 데이터가 이전 데이터와 다르지 않은 경우 React Query는 계속해서 이전 데이터를 사용하고 변경 사항을 알리지 않습니다.

> 여기서 `staleTime`이 사용됩니다. `staleTime`을 사용하면 오래된 데이터가 만료된 것으로 간주되기 전에 유효한 `(stale)`로 간주되는 기간을 지정할 수 있습니다. 기본적으로 `staleTime`은 0으로 설정되며 이는 이전 데이터가 여전히 유효한지 고려할 시간 제한이 없음을 의미합니다. 그러나 오래된 데이터가 만료된 것으로 간주되기 전에 특정 시간 동안 지속되도록 `staleTime`을 설정할 수 있습니다.

> 오래된 데이터를 식별하여 성능을 최적화하고 `서버'에 대한 `요청'의 양을 줄입니다. `component` 요청이 있을 때마다 항상 `fetch`하는 대신 `React Query`는 여전히 유효한 동안 이전 데이터를 사용하여 대역폭을 절약하고 데이터 렌더링 속도를 높입니다.

> 반응 개발 도구를 설치합니다. 오래된 데이터는 `(stale)`을 표시하고 `active`를 다시 추가합니다(그래서 어떤 종류의 `query key`가 호출되는지 알 수 있음) 새 데이터는 오래되었지만 `inactive`입니다.

- `cacheTime` (기본값 `5*60*1000` ms, 즉 5분): 데이터가 캐시에서 삭제되는 시간입니다. 데이터가 "부실"하지만 `stateTime < cacheTime`을 설정했기 때문에 캐시에서 지워지지 않았을 수 있습니다. 일반적으로 사람들은 `stateTime < cacheTime`을 설정합니다.

> 오래된(오래된) 데이터가 있는 경우 해당 데이터의 쿼리를 호출하면 API를 다시 가져옵니다. 오래되지 않은 경우 API를 다시 가져오지 마십시오. 기본값은 staleTime이 0ms이므로 오래되었습니다. 또는 `staleTime을 60 * 1000으로 설정하여 1분 후에는 오래되고 1분 후에는 api를 호출하지 않습니다.`

> 메모리에서 제거된 데이터(즉, cacheTime이 오래됨)`인 경우 `해당 데이터 쿼리`를 호출하면 API를 `가져옵니다`(물론). 메모리에서 지워지지 않았지만 `stale`인 경우 암시적으로 `data Cached`및`fetchApi`를 반환하고 가져온 후 캐시된 데이터를 업데이트하고 새 데이터를 반환합니다.

# Demo

기본 `cacheTime`을 **5분**으로 사용하고 `staleTime`을 `0`으로 사용한다고 가정합니다.

```jsx
function A() {
  const result = useQuery({ queryKey: ["todos"], queryFn: fetchTodos });
}
function B() {
  const result = useQuery({ queryKey: ["todos"], queryFn: fetchTodos });
}
function C() {
  const result = useQuery({ queryKey: ["todos"], queryFn: fetchTodos });
}
```

# 사례 데모

**_ A component được Mount _**

> 이전에 ['todos']를 사용한 쿼리가 없으므로 데이터를 가져옵니다.
> 가져오기가 완료되면 데이터가 ['todos'] 키 아래에 캐시됩니다.
> 후크는 0s 이후에 데이터를 부실(오래된) 것으로 표시합니다.

**_A와 B의 fetchTodos 함수가 동일한지 여부는 중요하지 않습니다. 동일한 키를 가진 2개의 구성 요소 => 동일한 데이터를 가리키기 때문에 B의 fetch api는 B와 A의 모든 관련 상태 쿼리를 업데이트합니다. _**

> `fetchData`가 성공하면 ['todos'] 키가 있는 `cache data`가 업데이트되고 구성요소 A와 B도 모두 새 데이터로 업데이트됩니다.
> 이제 더 이상 사용되지 않는 A와 B `unMount`는 더 이상 캐시 데이터['todos']를 구독하지 않으므로 데이터['todos']는 비활성으로 간주됩니다.

` 비활성 상태이므로 cacheTime이 5분 카운트다운을 시작합니다.`

> `cacheTime`이 끝나기 전에 C 구성 요소가 마운트됩니다. 캐시 데이터 ['todos']는 즉시 C로 반환되고 `fetchTodos`는 백그라운드에서 실행됩니다. 완료되면 새 데이터로 캐시를 업데이트합니다.

`드디어 C 언마운트`
다음 5분 동안 아무도 캐시 데이터['todos']를 구독하지 않으며 캐시 데이터['todos']에서 `result`가 완전히 지워집니다.

순간의 상태

- `isLoading` 또는 `status === 'loading'` - 쿼리에 데이터가 없습니다.
- `isError` 또는 `status === 'error'` - 쿼리 오류 발생
- `isSuccess` 또는 `status === 'success'` - 쿼리가 성공했고 데이터를 사용할 수 있음

데이터에 대한 상태

- `error` - `isError === true`인 경우 `error`가 여기에 표시됩니다.
- `data` - `isSuccess === true`인 경우 `data`가 여기에 나타납니다.

특히 `fetchStatus`

- `isFetching` 또는 `fetchStatus === 'fetching'` - 가져오기 API.
- `isPaused` 또는 `fetchStatus === 'paused'` - 쿼리가 API를 가져오려고 하지만 어떤 이유로 일시 중지되었습니다.
- `fetchStatus === 'idle'` - 쿼리가 아무 작업도 수행하지 않음

### 상태가 너무 많아서 혼란스럽다면 `status`와 `fetchStatus`의 차이점은 무엇인가요?

기억해라

- 정보 `데이터`에 대한 `상태` 예 또는 아니오
- `fetchStatus`는 `queryFn`이 실행 중인지 여부에 대한 정보를 제공합니다.

## 메카니즘 `caching`

'오래된' 데이터는 해당 데이터의 쿼리를 호출할 때 API를 다시 가져옵니다. `stale`이 아니면 API를 다시 가져오지 마세요.

메모리에서 지워진 데이터(즉, `cacheTime` 오버)는 해당 데이터를 다시 쿼리할 때 API를 다시 가져옵니다. 메모리에서 지워지지 않았지만 `stale`이 있으면 캐시된 데이터를 반환하고 암시적 API를 가져옵니다. 가져온 후 캐시된 데이터를 업데이트하고 새 데이터를 반환합니다.

# caching 수명 주기:

- 캐시 데이터가 있거나 없는 `Query Instance`

> 쿼리 인스턴스는 서버에서 쿼리한 데이터를 캐시합니다. 이것은 `useQuery`를 사용하여 쿼리를 실행할 때 해당 쿼리의 결과가 React 쿼리 캐시에 저장됨을 의미합니다.

> 동일한 queryKey로 쿼리를 두 번째로 실행하면 React Query는 서버에 새 쿼리 요청을 보내는 대신 캐시에서 결과를 반환합니다. 이렇게 하면 서버 로드가 줄어들고 애플리케이션 성능이 향상됩니다.

- 언더그라운드 페칭(백그라운드 페칭)
  > 암시적으로 데이터 가져오기를 수행하고, 데이터가 반환될 때까지 데이터를 비교하고 UI에 업데이트하여 사용자 경험을 방해하지 않고 사용자 경험(UX)을 높입니다.
- 비활성 쿼리
  > 즉 암시적 데이터 가져오기가 성공적으로 수행되면 쿼리가 성공적으로 수행되었음을 의미하며 이 단계에서는 데이터를 업데이트하기만 하면 됩니다.
- 메모리에서 캐시 지우기(가비지 컬렉션)

> cacheTime 쿼리가 오래되면 구성 요소가 'unMount'되고 이전에 저장된 데이터가 캐시에서 완전히 지워집니다.
